\relax 
\citation{pyop2isc}
\citation{IstvanHydra}
\citation{Fenics}
\citation{fluidity_manual_v4}
\citation{lizst}
\citation{nek5000}
\citation{firedrake-code}
\@writefile{toc}{\contentsline {section}{\numberline {I}Introduction}{1}}
\citation{quadrature1}
\citation{fluidity_manual_v4}
\citation{ufl}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces General structure of a local assembly kernel generated by Firedrake.}}{2}}
\newlabel{code:general-structure}{{1}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {II}Background}{2}}
\newlabel{sec:background}{{II}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Local assembly code generated by Firedrake for a Helmholtz problem on a 2D triangular mesh with Lagrange $p=1$ elements.}}{2}}
\newlabel{code:helmholtz}{{2}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Local assembly code generated by Firedrake for a Burgers problem on a 3D tetrahedral mesh with Lagrange $p=1$ elements.}}{2}}
\newlabel{code:burgers}{{3}{2}}
\citation{SLP}
\@writefile{lot}{\contentsline {table}{\numberline {I}{\ignorespaces Type and variable names used in the various code snippets to identify local assembly objects.}}{3}}
\newlabel{table:map-name-letters}{{I}{3}}
\@writefile{toc}{\contentsline {section}{\numberline {III}Code Transformations}{3}}
\newlabel{sec:code-transf}{{III}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {III-A}}Padding and Data Alignment}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {III-B}}Generalized Loop-invariant Code Motion}{4}}
\newlabel{sec:code-transf-licm}{{\unhbox \voidb@x \hbox {III-B}}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {III-C}}Model-driven Vector-register Tiling}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Local assembly code generated by Firedrake when padding, data alignment, and $licm$ are applied to the Helmholtz problem given in Figure\nobreakspace  {}2\hbox {}. Data alignment and padding are for an AVX machine. In this specific case, sub-expressions invariant to $j$ are identical to those invariant to $k$, so they can be precomputed once in a single loop $r$; in general, this might not be the case.}}{4}}
\newlabel{code:helmholtz-licm}{{4}{4}}
\newlabel{outer-product}{{1}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Outer-product vectorization by permuting values in a vector register.}}{5}}
\newlabel{fig:vect-by-vect}{{5}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Restoring the storage layout after $op$-$vect$. The figure shows how 4$\times $4 elements in the top-left block of the stiffness matrix $A$ can be moved to their correct positions. Each rotation, represented by a group of three same-colored arrows, is implemented by a single vector shuffle intrinsics.}}{5}}
\newlabel{fig:restore-layout}{{6}{5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {III-D}}Expression Splitting}{5}}
\newlabel{sec:expr-split}{{\unhbox \voidb@x \hbox {III-D}}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Local assembly code generated by Firedrake when padding, data alignment, $licm$ and $op$-$vect$ are applied to the Helmholtz problem given in Figure\nobreakspace  {}2\hbox {}. Here, we assume the polynomial order is $p=2$, since $op$-$vect$ can not be used when an iteration space dimension is smaller than the vector length. The original size of the $j$-$k$ iteration space (i.e. before padding was applied) was 6$\times $6. In this example, the unroll-and-jam factor is 1.}}{5}}
\newlabel{code:helmholtz-opvect}{{7}{5}}
\citation{FFC-Compiler}
\citation{pyop2isc}
\citation{inter-kernel-vect}
\citation{pyop2isc}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Local assembly code generated by Firedrake when $split$ is applied to the optimized Helmholtz problem given in Figure\nobreakspace  {}4\hbox {}. In this example, the split factor is 2.}}{6}}
\newlabel{code:helmholtz-split}{{8}{6}}
\@writefile{lot}{\contentsline {table}{\numberline {II}{\ignorespaces Overview of code transformations for Firedrake-generated assembly kernels.}}{6}}
\newlabel{table:code-transformations}{{II}{6}}
\@writefile{toc}{\contentsline {section}{\numberline {IV}Overview of COFFEE}{6}}
\newlabel{sec:pyop2-compiler}{{IV}{6}}
\newlabel{algo:PyOP2Compiler}{{7}{6}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Pseudocode of the COFFEE pipeline.}}{6}}
\@writefile{toc}{\contentsline {section}{\numberline {V}Performance Evaluation}{7}}
\newlabel{sec:perf-results}{{V}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {V-A}}Experimental Setup}{7}}
\newlabel{algo:applyCostModel}{{8}{7}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces The cost model is employed by the compiler to estimate the most suitable unroll-and-jam (when $op$-$vect$ is used) and split factors, avoiding the overhead of auto-tuning.}}{7}}
\citation{IACA}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {V-B}}Impact of Generalized Loop-invariant Code Motion}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {V-C}}Impact of Vector-register Tiling}{8}}
\newlabel{sec:perf-eval-opvect}{{\unhbox \voidb@x \hbox {V-C}}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces Speed-ups obtained by applying $op$-$vect$ on top of $licm$-$ap$ to the Helmholtz kernel. Tri, Tet, and Prism stand, respectively, for triangual, tetrahedral and prismatic mesh. CM stands for cost model.}}{8}}
\newlabel{fig:opvect-helmholtz-speedup}{{11}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces Speed-ups obtained by applying $op$-$vect$ on top of $licm$-$ap$ to the Diffusion kernel. Tri, Tet, and Prism stand, respectively, for triangual, tetrahedral and prismatic mesh. CM stands for cost model.}}{8}}
\newlabel{fig:opvect-diffusion-speedup}{{12}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {V-D}}Impact of Expression Splitting}{8}}
\newlabel{sec:perf-results-split}{{\unhbox \voidb@x \hbox {V-D}}{8}}
\citation{Fenics}
\citation{quadrature1}
\citation{nek5000-web-page}
\citation{Fenics}
\citation{fluidity_manual_v4}
\citation{FFC-TC}
\citation{Francis}
\citation{quadrature1}
\newlabel{table:perf-results-licm}{{\unhbox \voidb@x \hbox {V-B}}{9}}
\@writefile{lot}{\contentsline {table}{\numberline {III}{\ignorespaces Impact of generalized loop-invariant code motion ($licm$ column) on the Helmholtz, Diffusion and Burgers problems, for three kind of elements belonging to the Lagrange family (triangle, tetrahedron, prism), for the range of polynomial orders $p \in \delimiter "4266308 $1, 4$\delimiter "5267309 $. Each entry indicates the range of speed-ups obtained over the non-optimized implementation. The column $licm$-$ap$ illustrates the combination of $licm$ with data alignment and padding. Results are shown for both the Sandy Bridge and the Phi machine.}}{9}}
\@writefile{lof}{\contentsline {figure}{\numberline {13}{\ignorespaces Speed-ups obtained by applying $op$-$vect$ on top of $licm$-$ap$ to the Burgers kernel. Tri, Tet, and Prism stand, respectively, for triangual, tetrahedral and prismatic mesh. CM stands for cost model.}}{9}}
\newlabel{fig:split-burgers-speedup}{{13}{9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {V-E}}Comparison with Fenics Form Compiler's built-in Optimizations}{9}}
\@writefile{toc}{\contentsline {section}{\numberline {VI}Related Work}{9}}
\newlabel{sec:related-work}{{VI}{9}}
\citation{quadrature1}
\citation{Markall20101815}
\citation{petsc-integration-gpu}
\citation{assembly-opencl}
\citation{Pueschel:05}
\citation{Spampinato:14}
\citation{op2-main}
\citation{pyop2isc}
\citation{pochoir}
\citation{stencil-compiler}
\citation{PLUTO}
\citation{modeldriven}
\citation{nek5000}
\citation{ATLAS}
\citation{FFTW}
\bibstyle{plain}
\bibdata{biblio}
\bibcite{IACA}{1}
\bibcite{firedrake-code}{2}
\bibcite{ufl}{3}
\bibcite{fluidity_manual_v4}{4}
\bibcite{PLUTO}{5}
\bibcite{lizst}{6}
\bibcite{FFTW}{7}
\bibcite{stencil-compiler}{8}
\bibcite{FFC-Compiler}{9}
\bibcite{FFC-TC}{10}
\bibcite{petsc-integration-gpu}{11}
\bibcite{assembly-opencl}{12}
\newlabel{table:comparison-to-FFC-opt}{{\unhbox \voidb@x \hbox {V-E}}{10}}
\@writefile{lot}{\contentsline {table}{\numberline {IV}{\ignorespaces Summary of performance comparison between FEniCS and COFFEE on the Sandy Bridge machine. The slow down and speed up columns compare the best COFFEE implementation and the FEniCS implementation with optimizations enabled.}}{10}}
\@writefile{toc}{\contentsline {section}{\numberline {VII}Conclusions}{10}}
\newlabel{sec:conclusions}{{VII}{10}}
\@writefile{toc}{\contentsline {section}{References}{10}}
\bibcite{SLP}{13}
\bibcite{Fenics}{14}
\bibcite{pyop2isc}{15}
\bibcite{Markall20101815}{16}
\bibcite{op2-main}{17}
\bibcite{quadrature1}{18}
\bibcite{nek5000-web-page}{19}
\bibcite{Pueschel:05}{20}
\bibcite{inter-kernel-vect}{21}
\bibcite{IstvanHydra}{22}
\bibcite{Francis}{23}
\bibcite{nek5000}{24}
\bibcite{Spampinato:14}{25}
\bibcite{modeldriven}{26}
\bibcite{pochoir}{27}
\bibcite{ATLAS}{28}
