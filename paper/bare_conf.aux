\relax 
\citation{pyop2isc}
\citation{OP2-hydra}
\citation{Fenics}
\citation{fluidity_manual_v4}
\citation{lizst}
\citation{firedrake}
\citation{nek5000}
\@writefile{toc}{\contentsline {section}{\numberline {I}Introduction}{1}}
\citation{quadrature1}
\citation{fluidity_manual_v4}
\citation{ufl}
\@writefile{toc}{\contentsline {section}{\numberline {II}Background}{2}}
\newlabel{sec:background}{{II}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Local assembly code generated by Firedrake for a Helmholtz problem on a 2D triangular mesh with Lagrange $p=1$ elements.}}{2}}
\newlabel{code:helmholtz}{{1}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Local assembly code generated by Firedrake for a Burgers problem on a 3D tetrahedral mesh with Lagrange $p=1$ elements.}}{2}}
\newlabel{code:burgers}{{2}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {III}Code Transformations}{3}}
\newlabel{sec:code-transf}{{III}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {III-A}}Padding and Data Alignment}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {III-B}}Generalized Loop-invariant Code Motion}{3}}
\newlabel{sec:code-transf-licm}{{\unhbox \voidb@x \hbox {III-B}}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Local assembly code generated by Firedrake when padding, data alignment, and $licm$ are applied to the Helmholtz problem given in Figure\nobreakspace  {}1\hbox {}. Data alignment and padding are for an AVX machine. In this specific case, sub-expressions invariant to $j$ are identical to those invariant to $k$, so they can be precomputed once in a single loop $r$; in general, this might not be the case.}}{3}}
\newlabel{code:helmholtz-licm}{{3}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {III-C}}Domain-driven Vector-register Tiling}{3}}
\newlabel{outer-product}{{1}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Outer-product vectorization by permuting values in a vector register.}}{4}}
\newlabel{fig:vect-by-vect}{{4}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Restoring the storage layout after $op$-$vect$. The figure shows how 4$\times $4 elements in the top-left block of the stiffness matrix $A$ can be brought to their correct positions.}}{4}}
\newlabel{fig:restore-layout}{{5}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {III-D}}Expression Splitting}{4}}
\citation{FFC-Compiler}
\citation{pyop2isc}
\citation{inter-kernel-vect}
\citation{quadrature-cuda}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Local assembly code generated by Firedrake when padding, data alignment, $licm$ and $op$-$vect$ are applied to the Helmholtz problem given in Figure\nobreakspace  {}1\hbox {}. Here, we assume the polynomial order is $p=2$, since $op$-$vect$ can not be used when an iteration space dimension is smaller than the vector length. The original size of the $j$-$k$ iteration space (i.e. before padding was applied) was 6$\times $6. In this example, the unroll-and-jam factor is 1.}}{5}}
\newlabel{code:helmholtz-opvect}{{6}{5}}
\@writefile{lot}{\contentsline {table}{\numberline {I}{\ignorespaces Overview of code transformations for Firedrake-generated assembly kernels.}}{5}}
\newlabel{table:code-transformations}{{I}{5}}
\@writefile{toc}{\contentsline {section}{\numberline {IV}Overview of the XY Compiler}{5}}
\newlabel{sec:pyop2-compiler}{{IV}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Local assembly code generated by Firedrake when $split$ is applied to the optimized Helmholtz problem given in Figure\nobreakspace  {}3\hbox {}. In this example, the split factor is 2.}}{5}}
\newlabel{code:helmholtz-split}{{7}{5}}
\newlabel{algo:PyOP2Compiler}{{6}{6}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Pseudocode of the XY pipeline.}}{6}}
\newlabel{algo:applyCostModel}{{7}{6}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces The cost model is employed by the compiler to estimate the most suitable unroll-and-jam (when $op$-$vect$ is used) and split factors, avoiding the overhead of auto-tuning.}}{6}}
\@writefile{toc}{\contentsline {section}{\numberline {V}Performance Evaluation}{6}}
\newlabel{sec:perf-results}{{V}{6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {V-A}}Experimental Setup}{6}}
\citation{nek5000-web-page}
\citation{Fenics}
\citation{fluidity_manual_v4}
\citation{FFC-TC}
\citation{Francis}
\citation{quadrature1}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {V-B}}Impact of Generalized Loop-invariant Code Motion}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {V-C}}Impact of Vector-register Tiling}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {V-D}}Impact of Expression Splitting}{7}}
\newlabel{fig:opvect-helmholtz-speedup}{{\unhbox \voidb@x \hbox {V-D}}{7}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces Speed-ups obtained by applying $op$-$vect$ on top of $licm$-$ap$ to the Helmholtz kernel.}}{7}}
\newlabel{fig:opvect-diffusion-speedup}{{\unhbox \voidb@x \hbox {V-D}}{7}}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces Speed-ups obtained by applying $op$-$vect$ on top of $licm$-$ap$ to the Diffusion kernel.}}{7}}
\citation{quadrature1}
\citation{Markall20101815}
\citation{petsc-integration-gpu}
\citation{assembly-opencl}
\citation{Pueschel:05}
\citation{Spampinato:14}
\citation{op2-main}
\citation{pyop2isc}
\citation{pochoir}
\citation{stencil-compiler}
\citation{PLUTO}
\citation{modeldriven}
\citation{nek5000}
\citation{ATLAS}
\citation{FFTW}
\newlabel{table:perf-results-licm-helmholtz}{{\unhbox \voidb@x \hbox {V-B}}{8}}
\@writefile{lot}{\contentsline {table}{\numberline {II}{\ignorespaces Impact of generalized loop-invariant code motion ($licm$ column) on the Helmholtz, Diffusion and Burgers problems, for three kind of elements belonging to the Lagrange family (triangle, tetrahedron, prism), for the range of polynomial orders $p$ $\in $ $\delimiter "4266308 $1, 4$\delimiter "5267309 $. Each entry indicates the range of speed-ups obtained over the non-optimized implementation. The column $licm$-$ap$ illustrates the combination of $licm$ with data alignment and padding. Results are shown for both the Sandy Bridge and the Phi machine.}}{8}}
\newlabel{fig:opvect-burgers-speedup}{{\unhbox \voidb@x \hbox {V-D}}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces Speed-ups obtained by applying $op$-$vect$ on top of $licm$-$ap$ to the Burgers kernel.}}{8}}
\@writefile{toc}{\contentsline {section}{\numberline {VI}Related Work}{8}}
\newlabel{sec:related-work}{{VI}{8}}
\@writefile{toc}{\contentsline {section}{\numberline {VII}Conclusions}{8}}
\newlabel{sec:conclusions}{{VII}{8}}
\bibstyle{plain}
\bibdata{biblio}
\bibcite{ufl}{1}
\bibcite{fluidity_manual_v4}{2}
\bibcite{PLUTO}{3}
\bibcite{lizst}{4}
\bibcite{FFTW}{5}
\bibcite{stencil-compiler}{6}
\bibcite{FFC-Compiler}{7}
\bibcite{FFC-TC}{8}
\bibcite{petsc-integration-gpu}{9}
\bibcite{assembly-opencl}{10}
\bibcite{Fenics}{11}
\bibcite{pyop2isc}{12}
\bibcite{Markall20101815}{13}
\bibcite{op2-main}{14}
\bibcite{quadrature1}{15}
\bibcite{nek5000-web-page}{16}
\bibcite{Pueschel:05}{17}
\bibcite{inter-kernel-vect}{18}
\bibcite{Francis}{19}
\bibcite{nek5000}{20}
\bibcite{Spampinato:14}{21}
\bibcite{modeldriven}{22}
\bibcite{pochoir}{23}
\bibcite{ATLAS}{24}
\@writefile{toc}{\contentsline {section}{References}{9}}
